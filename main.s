; Создаем 2 макроса PORTB и DDRB, значения 0x04 и 0x05 являются адресами соответствующих регистров 
; их можно посмотреть на стр. 91 Atmega48P/88P/168P/328P datasheet
.equ	PORTB, 0x05							
.equ	DDRB, 0x04

.equ SPH, 0x3E								; Верхний байт Stack Pointer регистра (I/O port address)
.equ SPL, 0x3D								; Нижний байт Stack Pointer регистра (I/O post address)

.text										; Начало секции кода
.org 0x0000									; Начало вектора прерываний
jmp main									; Переходим в функцию main (reset вектор)

main:
	sbi	DDRB, 5								; Устанавливаем в бит 5 в DDRB (Data Direction Register B) 1 это говорит Arduino, что pin 13 на порту B будет выходным сигналом.
_main_loop:									; Метка main цикла 
	
	ldi r18, 100							; Загружаем число в регистр r18 (передаем параметр в wait_through_regs функцию)
	rcall wait_through_regs					; Вызываем функцию wait_through_regs
	
	sbi PORTB, 5							; Устанавливаем 1 в бит 5 PORTB регистра (загорается встроенный Arduino светодиод)  
	
	ldi r24, 25								; Загружаем число в регистр r24
	push r24								; Сохраняем значение регистра r24 в стек (Передаем параметр в функцию)
	rcall wait_through_stack				; Вызываем функцию wait_through_stack
	
	; Очищаем стек от параметров. Это нужно для того, чтобы увеличить Stack Pointer, 
	; если этого не сделать то рано или поздно произойдет переполнение стека.
	pop r24
	
	cbi PORTB, 5							; Устанавливаем 0 в бит 5 PORTB регистра (встроенный Arduino светодиод гаснет) 
	rjmp _main_loop							; Переходим в начало цикла
	ret
	
; Эта функция принимает 1 8-и битный параметр через регистр r18
wait_through_regs:
	; Сохраняем в стек значения всех регистров которые будут использоваться в функции
	push r18	
	push r19
	push r20
	
	; Переносим переданное значение в регистры r19 и r20
	mov r19, r18
	mov r20, r18
_wait_through_regs_loop:					; Метка wait цикла
	dec  r18								; Уменьшаем значение в регистре r18 на 1
    brne _wait_through_regs_loop			; Переходим в начало цикла, если регистр r18 не равен 0
	dec  r19								; Уменьшаем значение в регистре r19 на 1
    brne _wait_through_regs_loop			; Переходим в начало цикла, если регистр r19 не равен 0
	dec  r20								; Уменьшаем значение в регистре r20 на 1
    brne _wait_through_regs_loop			; Переходим в начало цикла, если регистр r20 не равен 0
	
	; Восстанавливаем значения использованных регистров из стека (Восстанавливаются регистры в порядке обратном порядку их сохранения)
	pop r20
	pop r19
	pop r18									
	ret
	

; Эта функция принимает 1 8-и битный параметр через стек
wait_through_stack:
	; Сохраняем в стек значения всех регистров которые будут использоваться в функции
	push r18
	push r19
	push r20
	push r26
	push r27
	
	; Сохраняем текущее значение Stack Pointer в 16-и битный регистр X (совмещенные r26:r27 регистры)
	in r26, SPL
	in r27, SPH
	
	; r26:r27 - X
	; r28:r29 - Y
	; r30:r31 - Z
	
	; Увеличиваем значение регистра X на 8 (это будет адрес переданного через стек параметра) 
	; над этим параметром в стеке теперь находятся сохраненные значения регистров r18 – r20; r26, r27 и 16-и битный адрес возврата. По этому прибавляем 8. 
	adiw r26, 8
	
    ld  r18, X								; Загружаем параметр из стека в r18
	
	; Вычитаем из регистра X, число 8. Тем самым в регистре X снова получаем адрес Stack Pointer
	; который был на момент его сохранения
	sbiw r26, 8								
	
    ; Переносим переданное значение в регистры r19 и r20
	mov r19, r18
	mov r20, r18
_wait_through_stack_loop: 								; Метка wait цикла
	dec  r18								; Уменьшаем значение в регистре r18 на 1
    brne _wait_through_stack_loop			; Переходим в начало цикла, если регистр r18 не равен 0
	dec  r19								; Уменьшаем значение в регистре r19 на 1
    brne _wait_through_stack_loop			; Переходим в начало цикла, если регистр r19 не равен 0
	dec  r20								; Уменьшаем значение в регистре r20 на 1
    brne _wait_through_stack_loop			; Переходим в начало цикла, если регистр r20 не равен 0
	
	; Восстанавливаем значения использованных регистров из стека (Восстанавливаются регистры в порядке обратном порядку их сохранения)
	pop r27
	pop r26
	pop r20
	pop r19
	pop r18	
	
	ret										; Выход из функции
	
.end										; Конец программы
